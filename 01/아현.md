# 1장 타입스크립트 알아보기
## 아이템1. 타입스크립트와 자바스크립트의 관계 이해하기
타입 체커를 통과한 타입스크립트는 자바스크립트의 상위집합

문법의 유효성과 동작의 이슈는 독립적인 문제 => 자바스크립트는 타입체커에서 지적당할 가능성이 있음

타입스크립트는 정적타입 시스템으로, 런타임에 오류를 발생시킬 코드를 미리 찾아냄

타입 구문을 통해 코드의 동작과 의도가 다른 부분을 찾아낼 수 있음

타입스크립트는 자바스크립트의 런타임 동작을 모델링함 + 실제로 작동하는 코드라도 추가적인 타입체크 ex. null + 7, 부족한 인수

타입스크립트가 이해하는 갑과 실제 값의 차이로 인해 오류가 생김 => Reason, Elm같은 언어를 사용하여 정확성을 보장하기도 하지만 마이그레이션 과정이 훨씬 복잡

## 아이템2. 타입스크립트 설정 이해하기
협업을 위해서 가급적 tsconfig.json 설정파일을 사용하여 명시 

동일한 코드에서 타입스크립트 에러가 재현되지 않는다면, 컴파일러 설징이 동일한지 우선 확인
```
// tsconfig.json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true
  }
}
```
- noImplicitAny
변수들이 미리 정의된 타입을 가져야 하는지 여부를 제어

타입스크립트는 타입 정보를 가질 때 가장 효과적이기 때문에, 되도록이면 noImplictAny를 설정하애함

문제를 발견하기 수월해지고, 코드의 가독성이 좋아지며, 개발자의 생산성이 향상됨

자바스크립트 기존 프로젝트를 타입스크립트로 전환하는 상황에서만 설정 해제 필요
- strictNullChecks
null과 undefined가 모든 타입에서 허용되는지 확인하는 설정

null과 undefined 관련 오류를 잡는데 도움이 되지만 코드 작성이 어려움

- strictFunctionTypes
함수 타입의 호환성을 더 엄격하게 검사

- strictBindCallApply
bind, call, apply 메서드의 사용을 엄격하게 검사

- strictPropertyInitialization
클래스의 멤버 변수를 초기화하지 않으면 에러를 발생시킴

- noImplicitThis
this의 타입을 명시하지 않으면 에러를 발생시킴

- alwaysStrict
생성된 JS코드에 항상 `"use strict";`를 추가

## 아이템3. 코드 생성과 타입이 관계없음을 이해하기
타입스크립트 컴파일러
- 최신 타입스크립트/자바스크립트를 브라우저에서 동작할 수 있도록 구버전의 자바스크립트로 트랜스파일
- 코드의 타입 오류를 체크
타입스크립트가 자바스크립트로 변환될 때 코드 내의 타입에는 영향을 주지 않으며, 실행 시점에도 타입은 영향을 미치지 않음
#### 타입 오류가 있는 코드도 컴파일이 가능합니다
컴파일은 타입 체크와 독립적으로 동작하기 때문에, 타입 오류가 있는 코드도 컴파일이 가능함

만약 오류가 있을 때 컴파일하지 않으려면 noEmitOnError 설정
#### 런타임에는 타입 체크가 불가능합니다
자바스크립트로 컴파일되는 과정에서 모든 인터페이스, 타입, 타입 구문은 그냥 제거됨

런타임에 타입을 지정하기 위해서는 태그된 유니온과 속성 체크 방법을 사용

#### 타입 연산은 런타임에 영향을 주지 않습니다
as number 타입 단언문을 통해 타입 연산을 하더라도 값을 정제하기 위해서는 자바스크립트 연산을 통해 변환을 수행해야함
#### 런타임 타입은 선언된 타입과 다를 수 있습니다
#### 타입스크립트 타입으로는 함수를 오버로드할 수 없습니다
#### 타입스크립트타입은 런타임 성능에 영향을 주지 않습니다
## 아이템4. 구조적 타이핑에 익숙해지기
자바스크립트는 본질적으로 덕 타이핑 기반으로, 함수의 매개변수 값이 모두 제대로 주어진다면 신경 쓰지 않고 사용

*덕 타이핑: 객체가 어떤 타입에 부합하는 변수와 메서드를 가질 경우 객체를 해당 타입에 속하는 것으로 간주하는 방식
## 아이템5. any 타입 지양하기
#### any 타입에는 타입 안전성이 없습니다
#### any는 함수 시그니처를 무시해 버립니다
#### any 타입에는 언어 서비스가 적용되지 않습니다
#### any 타입은 코드 리팩터링 때 버그를 감춥니다
#### any는 타입 설계를 감춰버립니다
#### any는 타입시스템의 신뢰도를 떨어뜨립니다

# 2. 타입스크립트의 타입 시스템
## 아이템6. 편집기를 사용하여 타입 시스템 탐색하기
## 아이템7. 타입이 값들의 집합이라고 생각하기
## 아이템8. 타입 공간과 값 공간의 심벌 구분하기
## 아이템9. 타입 단언보다는 타입 선언을 사용하기
## 아이템10. 객체 래퍼 타입 피하기
## 아이템11. 잉여 속성 체크의 한계 인지하기
## 아이템12. 함수 표현식에 타입 적용하기
## 아이템13. 타입과 인터페이스의 차이점 알기
## 아이템14. 타입 연산과 제너릭 사용으로 반복 줄이기
## 아이템15. 동적 데이터에 인덱스 시그니처 사용하기
## 아이템16. number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기
## 아이템17. 변경 관련된 오류 방지를 위해 readonly 사용하기
## 아이템18. 매핑된 타입을 사용하여 값을 동기화하기
