# 7장 코드를 작성하고 실행하기

## 아이템 53. 타입스크립트 기능보다는 ECMAScript 기능을 사용하기

- 일반적으로 TS 코드에서 타입 정보를 제거하면 JS가 되지만, 열거형, 매개변수 속성, 트리플 슬래시 임포트, 데코레이터는 아님
- TS 열거형

```typescript
enum Flavor {
  VANILLA = 0,
  CHOCOLATE = 1,
  STRAWBERRY = 2,
}

let flavor = Flavor.CHOCOLATE; // 타입이 Flavor

Flavor; // 자동완성 추천: VANILLA, CHOCOLATE, STRAWBERRY
Flavor[0]; // VANILLA
```

1. 숫자 열거형에 0, 1, 2 외의 다른 숫자가 할당되면 위험 (비트 플래그 구조를 표현하기 위해 설계되었기 때문)
2. 상수 열거형은 보통의 열거형과 달리 런타임에서 완전 제거됨  
   예제를 const enum Flavor 로 바꾸면, 컴파일러는 Flavor.CHOCOLATE을 0으로 바꿈
3. PreserveConstEnums 플래그를 설정한 상수 열거형은 열거형 정보를 유지함
4. 문자열 열거형은 런타임의 타입 안정성/투명성 제공  
   but, 구조적 타이핑이 아닌 명목적 타이핑 사용

- 매개변수 속성

  1. TS는 타입제거가 일어나 코드가 줄어들지만, 매개변수 속성은 코드가 늘어나게 됨
  2. 런타임에는 실제로 사용되지만, TS 관점에서 사용되지 않는 것처럼 보임
  3. 일반 속성과 섞어서 사용하면 클래스 설계 시 혼란스러움

- 네임스페이스와 트리플 슬래시 임포트

  1. 네임스페이스는 module과 같은 기능
  2. 호환성을 위해 남아있을 뿐이며 ECMAScript의 import/export 사용해야함

- 데코레이터
  1. 애너테이션을 붙이거나 기능을 추가하는데 사용
  2. 표준화가 완료되지 않았기에 호환성이 깨질 가능성 있음
  3. 꼭 필요한 프레임워크를 사용하는게 아니면 사용 x

## 아이템 54. 객체를 순회하는 노하우

- 객체 순회 시, 키 타입을 파악하고 있다면 let k: keyof 와 for-in 루프 사용 가능
  함수의 매개변수로 쓰이는 객체에는 추가적인 키 존재 가능
- 객체 순회하며 키/값을 얻는 일반적 방법은 Object.entries를 사용하는 것  
  직관적이지는 않지만, 복잡한 기교없이 사용 가능

## 아이템 55. DOM 계층 구조 이해하기

- DOM에는 타입 계층 구조가 존재하며 DOM 타입은 TS에서 중요한 정보
- DOM 엘리먼트/이벤트에는 구체적인 타입 정보를 사용하거나, TS가 추론 가능하도록 문맥 정보 활용해야함

## 아이템 56. 정보를 감추는 목적으로 private 사용하지 않기

- public, protected, private 접근 제어자는 TS 시스템에서만 강제되며, 컴파일 후에는 제거됨  
  단언문을 사용하면, TS에서도 private 접근 가능함  
  즉, 정보를 감추기위해 private 사용은 안됨
- 데이터를 감추려면 클로저를 활용하기

## 아이템 57. 소스맵을 사용하여 타입스크립트 디버깅하기

- 디버거는 런타임에 동작하며, 코드가 어떤 과정을 거쳐 만들어졌는지 알지 못함  
  여러 과정을 거쳐 변환된 JS 코드는 복잡해 디버깅이 어려움
  이를 해결하기 위해 소스맵이라는 해결책 제시
- 소스맵: 변환된 코드의 위치와 심벌들을 원본 코드의 위치와 심벌들로 매핑
- 소스맵에 원본 코드가 포함되도록 설정될 수 있으며, 공개되지 않도록 설정 확인 필요

# 8장 타입스크립트로 마이그레이션하기

## 아이템 58. 모던 자바스크립트로 작성하기

- TS는 타입 체크 기능 외 TS 코드를 특정 버전의 JS로 컴파일도 가능  
  TS는 JS의 상위집합이기 때문

- ECMAScript 모듈 사용하기  
  마이그레이션 대상 JS코드가 단일 파일이거나 비표준 모듈시스템이라면 ES모듈로 전환 추천

- 프로토타입 대신 클래스 사용하기  
  프로토타입보다 클래스로 구현한 문법이 간결하고 직관적임  
  TS언어 서비스를 활용하면 간단히 클래스 객체로 변환도 가능

- var 대신 let/const 사용하기  
  let/const 를 사용하면 스코프 문제를 피할 수 있음  
  기존의 var를 let/const로 바꾸면 일부코드에서 오류가 표시될 수 있으며 이는 스코프 문제가 존재하는 코드임

- for(;;) 대신 for-of 또는 배열 메서드 사용하기  
  for-of 루프는 코드가 짧고 인덱스 변수 미사용으로 실수를 줄일 수 있음  
  인덱스 변수 필요 시, forEach 메서드 사용

- 함수 표현식보다 화살표 함수 사용하기  
  화살표 함수 사용 시 상위 스코프의 this 유지 가능
  또한, 인라인(콜백)에서 화살표 함수가 더 직관적이며 코드가 간결해짐

- 단축 객체 표현과 구조 분해 할당 사용하기  
  단축 객체 표현은 중복된 이름 생략으로 코드가 더 간결해져 가독성이 좋아짐
  구조 분해 할당도 사용 시, 문법이 간결해지고 변수를 사용할 때 실수를 줄일 수 있음

- 함수 매개변수 기본값 사용하기  
  함수 매개변수는 선택적이며, 지정하지 않으면 undefined
  기본값 지정 시 코드가 간결해지며, 기본값 기반으로 타입 추론이 가능해짐

- 저수준 프로미스나 콜백 대신 async/await 사용하기  
  async/await를 사용하면 코드가 간결해져 버그나 실수 방지가 가능하며, 비동기 코드에 타입 정보가 전달되어 타입 추론 가능

- 타입스크립트에 use strict 넣지 않기  
  TS에서 수행되는 안정성 검사가 use strict보다 더 엄격한 체크를 하기 때문에 무의미  
  TS 코드에 use strict 대신 alwaysStrict 설정 사용

## 아이템 59. 타입스크립트 도입 전에 @ts-check와 JSDoc으로 시험해보기

- @ts-check 지시자를 사용하면 TS 전환 시 발생할 문제를 JS에서 미리 시험 가능  
  그러나 @ts-check는 noImplicitAny 설정을 해제한 것보다 헐거운 체크를 수행
- JSDoc 스타일의 주석을 사용중이라면, 기존 주석에 타입 체크가 동작하게되고 수많은 오류가 발생하겠지만 차근차근 타입정보를 추가해나가면 됨
- @ts-check와 JSDoc 주석을 너무 장기간 사용하는 것은 좋지 않음  
  주석이 코드 분량을 늘려 로직 해석에 방해되기 때문

## 아이템 60. allowJs로 타입스크립트와 자바스크립트 같이 사용하기

- TS와 JS가 공존하는 방법의 핵심은 allowJs 컴파일러 옵션임  
  각 파일을 서로 임포트할 수 있게 해줌

## 아이템 61. 의존성 관계에 따라 모듈 단위로 전환하기

- 점진적 마이그레이션을 할 때는 모듈 단위로 하는 것이 이상적  
  그러나, 해당 모듈이 의존하는 모듈에서 비롯되는 타입 오류가 발생  
  즉, 다른 모듈에 의존하지 않는 최하단 모듈부터 작성을 시작해야함

- 리팩토링을 할 부분을 발견해도 당장 하면 안됨  
  마이그레이션 작업을 끝낸 후 진행하는 것이 좋기에 목록 작성해두기

- 선언되지 않은 클래스 멤버  
  TS는 클래스 멤버 변수를 명시적으로 선언해야함  
  그렇지 않으면, 참조하는 속성마다 오류 발생

## 아이템 62. 마이그레이션의 완성을 위해 noImplicitAny 설정하기

- 마이그레이션의 마지막은 noImplicitAny 설정하는 것  
  설정되지 않은 상태라면, 타입 선언에서 비롯된 오류가 숨어 있기 때문에 완료가 아님

- 처음에는 로컬에서만 설정하고 작업하는 것이 좋음  
  원격에서는 설정 변화가 없기에 빌드가 실패하지 않기 때문  
  로컬에서만 오류로 인식하기에 수정된 부분만 커밋할 수 있어 점진적 마이그레이션 가능
