# 5장 any 다루기

## 아이템 38. any 타입은 가능한 한 좁은 범위에서만 사용하기

1. 의도치 않은 타입 안전성 손실을 피하기 위해 nay의 사용범위 최소화
2. 함수의 반환 타입이 any가 되면 타입 안정성이 안좋아짐  
   (반환값으로 다른 함수의 인수로 사용하면 그 함수도 any가 적용되기에)
3. 강제로 타입 오류를 제거하려면 any 대신 @ts-ignore 사용하기  
   (but, 근본적 해결법은 아니고 임시방편)

## 아이템 39. any를 구체적으로 변형해서 사용하기

- any는 모든 값을 아우르는 타입이므로 좀 더 구체적으로 표현할 수 있는 타입은 없는지 확인 필요
- any 보다 최소한으로 구체화할 수 있는 방안을 활용

```typescript
// 해당 예제에서 any 보단 any[] 가 더 합당
// 함수 내의 array.lenth 타입 체크 가능
// 반환 타입이 any 대신 number로 추론됨
// 함수 호출될 때 매개변수가 배열인지 체크 가능

function getLengthBad(array: any) {
  return array.length;
}

function getLength(array: any[]) {
  return array.length;
}
```

## 아이템 40. 함수 안으로 타입 단언문 감추기

- 함수 내부 로직이 복잡해서 안전한 타입으로 구현하기 어려운 경우가 많음
- 함수 내부는 타입 단언을 사용하고 함수 외부로 타입 정의를 명시하는 정도만 해도 됨

## 아이템 41. any의 진화를 이해하기

- 일반적 타입은 정제되기만 하지만, any는 진화 가능

```typescript
function range(start: number, limit: number) {
  const out = []; // any []
  for (let i = start; i < limit; i++) {
    out.push(i); // any []
  }
  // 타입이 any[] 였지만 number 값을 넣는 순간부터 타입은 number []로 진화
  return out; // number []
}
```

- any 를 진화시키기보다 명시적 타입 구문 사용을 권장

## 아이템 42. 모르는 타입의 값에는 any 대신 unknown을 사용하기

- 어떠한 타입이든 unknown에 할당 가능하지만 unknown은 unknown/any에만 할당 가능
  그렇기에 unkown은 any 대신 사용가능한 안전한 타입임
- unknown은 타입 단언문이나 타입체크를 사용하도록 강제할 수 있음  
  any와 달리 unknown로 반환될 경우 즉시 오류 발생 (any는 전염병처럼 퍼져나감)

## 아이템 43. 몽키 패치보다는 안전한 타입을 사용하기

- 객체에 임의의 속성을 추가하는 것은 좋은 설계가 아님  
  window같은 전역 객체에 속성 추가 시 의존성이 높아지게 됨  
  따라서, 전역 객체 등에 속성을 추가하지 않고 분리해서 사용하는 것을 권장

- Document 등의 내장 속성에 임의로 추가한 속성은 타입체커가 알 수 없음  
  따라서 추가한 속성을 분리할 수 없는 경우, 보강 또는 더 구체적인 타입 단언문 사용

## 아이템 44. 타입 커버리지를 추적하여 타입 안전성 유지하기

- noImplicitAny 가 설정되어 있어도, 명시적 any나 서드파티 타입 선언을 통해 any 존재 가능
- 프로젝트의 any 갯수 추적하는 것이 좋음
- type-coverage 패키지를 활용하여 추적 방법 존재 (-detail 플래그를 붙이면 any 타입 위치 출력 가능)

# 6장 타입 선언과 @tpyes

## 아이템 45. devDependencies에 typescript와 @types 추가하기

- npm은 3가지 종류의 의존성을 구분해서 관리하며, package.json 파일 내 별도 영역에 존재
  1. dependencies  
     프로젝트를 실행하는 데 필수적인 라이브러리들의 집합
  2. devDependencies  
     프로젝트 개발 및 테스트에 사용되지만 런타임에 필요 없는 라이브러리들의 집합
  3. peerDependecies  
     런타임에 필요하지만 의존성을 직접 관리하지 않는 라이브러리들의 집합
- TS와 관련된 라이브러리들은 일반적으로 devDependencies에 존재  
  TS는 개발 도구일뿐, 타입 정보는 런타임에 존재하지 않기 때문
- 모든 TS 프로젝트에서 공통적으로 고려해야할 의존성 2가지
  1. TS 자체 의존성을 고려해야 함  
     TS는 시스템 레벨 설치보다 devDependencies에 포함시켜 버전 통일
  2. 타입 의존성(@tpyes)를 고려 해야함
     @types 의존성은 dependencies가 아닌 devDependencies에 있어야 함

## 아이템 46. 타입 선언과 관련된 세 가지 버전 이해하기

- 타입 선언(@types)과 관련하여 라이브러리의 버전, 타입선언의 버전, 타입스크립트의 버전이 존재
- 실제 라이브러리와 타입 정보의 버전이 별도로 관리되는 방식은 4가지 문제점 존재

  1. 라이브러리를 업데이트 했지만 실수로 타입 선언은 업데이트 하지 않은 경우  
     새로운 기능 사용 시 타입 오류 발생  
     하위 호환성이 깨지는 변경이 있다면, 타입 체커를 통과해도 런타임에 오류 발생
  2. 라이브러리보다 타입 선언이 최신 버전인 경우  
     타입 체커는 최신 API를 기준으로 코드 검사를 실시하지만, 런타임에 실제로 쓰이는 것은 과거 버전임
  3. 프로젝트에서 사용하는 TS 버전보다 라이브러리에서 필요로 하는 TS 버전이 최신인 경우  
     @types 선언 자체에서 타입 오류 발생
  4. @types 의존성이 중복될 수도 있음  
     현재 프로젝트와 맞지 않는 버전의 @types에 의존하는 @types가 있다면 오류 발생

- 결론적으로 버전 통일이 중요함

## 아이템 47. 공개 API에 등장하는 모든 타입을 익스포트하기

- 공개 메서드에 등장한 어떤 형태의 타입이든 익스포트하기 (라이브러리 제작자에게 해당하는 말인듯?)

## 아이템 48. API 주석에 TSDoc 사용하기

- /\*_ 주석 생성 ~~~ _/ 으로 주석을 달면 편집기가 주석 정보를 표시해줌
- 주석에 타입 정보를 명시하면 안됨

## 아이템 49. 콜백에서 this에 대한 타입 제공하기

- TS 역시 this 바인딩을 그대로 적용
- 콜백 함수의 매개변수에 this 추가 시 this 바인딩 체크 가능

## 아이템 50. 오버로딩 타입보다는 조건부 타입을 사용하기

- 오버로딩 타입이 작성은 쉽지만 조건부 타입은 개별 타입의 유니온으로 일반화 하므로 타입이 더 정확해짐
- 조건부 타입은 삼항 연산자(?:)처럼 사용하면 됨

```typescript
function double<T extends number | string>(
  x: T
): T extends string ? string : number;
function double(x: any) {
  return x + x;
}
```

## 아이템 51. 의존성 분리를 위해 미러 타입 사용하기

- 필수가 아닌 의존성을 분리할 때는 JS 나 TS 개발자가 각자 필요한 모듈만 사용할 수 있도록 구조적 타이핑 사용

## 아이템 52. 테스팅 타입의 함정에 주의하기

- 콜백 함수 테스트 시 매개변수의 추론된 타입을 체크해야 하며, this도 테스트하는 것이 좋음
- 모듈에 의해 암시적으로 any가 반환될 수 있기에 타입 체커와 독립적으로 동작하는 도구로 테스트 권장
- dtslint 또는 타입시스템 외부에서 타입 검사하는 유사한 도구를 사용하는 것이 더 안전하고 간단
