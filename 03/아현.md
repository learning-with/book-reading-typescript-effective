# 5장 any 다루기
## 아이템38. any 타입은 가능한 한 좁은 범위에서만 사용하기
매개변수에서 타입 단언하거나 // @ts-ignore 사용, 객체의 일부 속성에서만 any 허용하는 등 any 지양
## 아이템39. any를 구체적으로 변형해서 사용하기
그냥 any보다 `any[]`, `{[id: string]: any}`, `() => any`처럼 구체적인 형태를 사용
## 아이템40. 함수 안으로 타입 단언문 감추기
복잡한 내부 로직으로 불필요한 예외 사항으로 타입 에러가 생긴다면, 함수 내부에서 타입 단언을 사용해서 숨기기
## 아이템41. any의 진화를 이해하기
배열에 값을 추가하면서 타입이 늘어나거나, 암시적 any의 초깃값이 null인 경우 할당하면서 타입이 추가됨
## 아이템42. 모르는 타입의 값에는 any 대신 unknown을 사용하기
unknown 타입을 사용하여 타입 단언문이나 타입 체크를 통한 타입 변환 이후 실행되도록 하길 권장
- `{}` 타입은 null과 undefined를 제외한 모든 값을 포함 => 생성자 함수
- object 타입은 모든 비기본형 타입으로 이뤄짐 boolean, string, number는 불가능하며 객체와 배열은 포함됨
## 아이템43. 몽키 패치보다는 안전한 타입을 사용하기
타입스크립트는 Document와 HTMLElement의 내장 속성은 알고 있지만, 전역 변수 등 임의로 추가한 속성에 대해서는 알지 못하므로 데이터를 분리하는 것 권장

불가피한 경우 interface의 보강(같은 이름으로 선언하여 추가)을 사용하거나 사용자 정의 인터페이스로 단언

혹은 모듈의 관점에서 global 선언으로 전역 스코프에 추가
```
declare global {
  interface Document {
    monky: string;
  }
}
```
## 아이템44. 타입 커버리지를 추적하여 타입 안전성 유지하기
npm의 type-coverage 패키지를 활용하여 any를 추적 가능

# 6장 타입 선언과 @types
## 아이템 45. devDependencies에 typescript와 @types 추가하기
## 아이템 46. 타입 선언과 관련된 세 가지 버전 이해하기
- 라이브러리의 버전
- 타입 선언(@types)의 버전
- 타입스크립트의 버전

번들된 타입에서는 @types의 버전 선택이 불가능함
## 아이템 47. 공개 API에 등장하는 모든 타입을 익스포트하기
## 아이템 48. API 주석에 TSDocs 사용하기
## 아이템 49. 콜백에서 this에 대한 타입 제공하기
## 아이템 50. 오버로딩 타입보다는 조건부 타입을 사용하기
```
function double<T extends number | string>(
  x: T
): T extends string ? string: number;
function double(x: any) { return x +x; }
```
## 아이템 51. 의존성 분리를 위해 미러 타입을 사용하기
## 아이템 52. 테스팅 타입의 함정에 주의하기
