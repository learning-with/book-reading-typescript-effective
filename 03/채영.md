# 5 any 다루기

any는 마이그레이션 시, 타입 체크를 비활성화 시켜줌

## 38 any 타입은 가능한 좁은 범위에서만 사용하기

- 사용 범위를 최소한으로 좁히기
- 변수 자체에 any 선언보다 타입체커가 오류를 반환하는 매개변수 부분에만 any 적용하기
- `@ts-ignore` 사용시 다음 줄의 오류가 무시되지만 근본적인 원인은 해결한 것이 아니므로 다른 곳에서 문제가 생길 가능성 있음.
- 객체에 any를 사용할 경우, 객체 전체에 any를 적용하지 말고 객체한 특정 프로퍼티에 사용하기

## 39 any를 구체적으로 변형해서 사용하기

- any 사용할 때는 정말 any말고 다른 구체적인 타입이 없는지 면밀히 검토해야함.
- any보다 더 정확하게 모델링 할 수 있도록 `any[]`또는 `{[id: string]: any}` 또는 `() => any`처럼 구체적인 형태를 사용해야한다.

## 40 함수 안으로 타입 단언문 감추기

- 객체가 같은지 체크하기 위해 객체 순회와 단언문이 코드에 직접 들어가는 것보다, 별도의 함수로 분리해 내는 것이 훨씬 좋은 설계다.
- 타입 선언문은 일반적으로 타입 안정성을 떨어뜨리지만 필요에 따라 현실적인 해결책이 된다. 불가피하게 사용해야 한다면, 정확한 정의를 가지는 함수 안으로 숨기도록 한다.

## 41 any의 진화를 이해하기

- 타입이 any[]로 선언될 경우 할당된 값에 따라 타입이 진화한다. 타입 진화는 타입 좁히기와 다름으로 배열에 다양한 타입의 요소를 넣으면 배열의 타입이 확장되며 진화한다.

```typescript
const result = []; // 타입이 any[]
result.push("a");
result; // 타입이 string[]
result.push(1);
result; // 타입이 (string | number)[]
```

- any 타입의 진화는 noImplicitAny가 설정된 상태에서 변수의 타입이 암시적 any인 경우에만 일어난다. (암시적 any인 상태에서 값을 할당하지 않은 상태로 사용하면 any 오류 발생)
- 명시적으로 any를 선언할 경우 타입이 그대로 유지된다.
- 암시적 any를 진화시키기보다 명시적 타입 구문을 사용하자.

## 42 모르는 타입의 값에는 any 대신 unknown을 사용하기

- any는 집합 개념보다는 어떤 타입으로도 할당 가능하기 때문에 any 타입보다는 unknown이 안전한 타입이다.
- 사용자가 타입 단언문이나 타입 체크를 사용하도록 강제하려면 unknown을 사용하자. (unknown으로 반환시 에러 발생.)
- null과 undefined가 불가하다고 생각드는 경우에는 unknown 대신 `{}` 사용하기
- object타입은 모든 비원시형타입(객체, 배열 등)으로 이루어진다.

## 43 몽키 패치보다는 안전한 타입을 사용하기

- 타입체커는 Document와 HTMLElement의 내장 속성에 대해는 알고 있지만 임의로 추가한 속성에 대해서는 알지 못해 오류가 나는 방법이 있다. 이때 any보다는 전역 변수나 Dom에 데이터를 저장하지 않고 document또는 DOM으로부터 데이터를 분리하는 방법이있다.
- 데이터 분리가 안될 시, interface의 특수 기능 중 하나의 보강(augmentation)을 사용하거나 더 구체적인 타입 단언문을 사용하는 방법이 있다.

#### any보다 나은 점

- 타입 안전성 증가
- 속성에 주석 붙이기 가능
- 속성에 자동완성 사용 가능
- 몽키 패치가 어떤 부분에 적용되었는지 정확한 기록이 남는다.

## 44 타입 커버리지를 추적하여 타입 안정성 유지하기

- 명시적 any나 서드파티 타입 선언(@types)을 통해 여전히 any 타입이 코드내에 존재할 경우 npm에서 type-cover-age 패키지를 활용하여 any를 추적할 수 있는 방법이 있다.

```bash
npm type-coverage --detail # any 타입이 있는 곳을 모두 출력해주는 명령어
```

# 6 타입 선언과 @types

## 45 devDependencies에 typescript와 @types 추가하기

- 타입스크립트를 프로젝트 devDependencies에 포함시키고 팀원 모두가 동일한 버전을 사용하도록 해야한다.
- @types 의존성은 dependencies가 아니라 devDependencies에 포함시켜야한다. 런타임에 @types가 필요한 경우라면 별도의 추가작업이 필요할 수도 있다.

## 46 타입 선언과 관련된 세 가지 버전 이해하기

- 라이브러리 버전, 타입 선언(@types)의 버전, 타입스크립트 버전 중 하나라도 버전이 맞지 않으면 의존성과 상관없어 보이는 곳에 엉뚱하게 오류가 발생할 수 있다.

### 라이브러리와 타입 정보의 버전이 별도로 관리되는 방식의 문제점

- 라이브러리만 업데이트되고 타입 선언의 버전은 업데이트하지 않은 경우의 발생. 만약 둘 중 하나의 버전이 버전이 맞춰지지 않을 경우 보강 기법을 활용하여 사용하려는 새 함수와 메서드의 타입 정보를 프로젝트 자체에 추가하는 방법과 타입 선언의 업데이트를 직접 작성하여 커뮤니티에 기여하는 방법 등이 있다.
- 라이브러리보다 타입 선언이 최신 버전일 경우 발생. 이 경우에는 라이브러리 버전을 올리거나 타입 선언의 버전을 내리자 = 버전 맞추기
- 프로젝트에서 사용하는 타입스크립트 버전보다 라이브러리에서 필요로 하는 타입스크립트 버전이 최신일 경우 발생. 프로젝트 버전 최신 버전 사용하거나, 진행하는 프로젝트 버전에 맞는 라이브러리 구 버전 설치.
- @types 의존성이 중복될 수 있다. `npm ls @types/foo` 실행하여 타입 선언 중복이 어디서 발생했는지 추적할 수 있다.

### 번들링 방식의 문제점

- 번들된 타입 선언에 보강 기법으로 해결할 수 없는 오류가 있는 경우, 또는 공개 시점에는 잘 동작했지만 타입스크립트 버전이 올라가면서 오류 발생.
- 프로젝트 내의 타입 선언이 다른 라이브러리의 타입 선언에 의존한다면 문제가 된다.
- 프로젝트 과거 버전에 있는 타입 선언에 문제가 있는 경우에는 과거 버전으로 돌아가서 패치 업데이트를 해야한다.
- 타입 선언의 패치 업데이트를 자주 하기 어렵다.

#### 번들링 방식

- 자체적으로 타입 선언 포함. 타입 선언이 생성된 경우라면 버전 불일치 문제를 해결하기는 한다. 하지만 DefinitelyTyped에 공개하여 커뮤니티에서 관리하고 유지보수하도록 맡기는 편이 좋다.

## 47 공개 API에 등장하는 모든 타입을 익스포트하기

공개 메서드에 등장한 어떤 형태의 타입이든 익스포트한다. 어차피 라이브러리 사용자가 추출할 수 있으므로, 익스포트하기 쉽게 만드는 것이 좋다.

## 48 API 주석에 TSDoc 사용하기

마크다운 형태로 꾸며지는 JSDoc 스타일로 사용자를 위해 주석을 만드는 것이 좋다. JSDoc에 @params, @return같은 규칙을 사용하려 TSDoc으로 사용해보자. 각 타입에 TSDoc을 사용하여 필드별로 설명을 볼 수 있다. 주석에 타입 정보 명시 금지, 주석은 간단하게 달기.

## 49 콜백에서 this에 대한 타입 제공하기

콜백 함수에서 this 사용할 경우 타입 정보 명시하기

```typescript
function addKeyListener(el: HTMLElement, fn: (this: HTMLElement, e: KeyboatdEvent) => void) {
  el.addEventListener("keydown", e => {
    fn.call(el, e); // 1개의 인수가 필요한데 2개를 가져왔습니다.
  });
}
```

## 50 오버로딩 타입보다는 조건부 타입을 사용하기

- 조건부 타입은 추가적인 오버로딩 없이 유니온 타입을 지원할 수 있다.
- 조건부 타입은 삼항 연산자처럼 사용하기,

```typescript
function double<T extends number | string>(x: T): T extends string ? string : number;
function double(x: any) {
  return x + x;
}
```

## 51 의존성 분리를 위해 미러 타입을 사용하기

- 필수 아닌 의존성을 분리할 때는 구조적 타이핑 사용하기
- 공개한 라이브러리를 사용하는 자바스크립트 사용자가 @types의존성을 가지지 않게 해야한다. 웹 개발자가 nodeJS 관련된 의존성을 가지지 않게 해야한다. 각자 필요한 모듈만 사용할 수 있도록 구조적 타이핑을 적용하자. (별도의 인터페이스 생성하기)

## 52 테스팅 타입의 함정에 주의하기

- 콜백이 있는 함수를 테스트할 때, 콜백 매개변수의 추론된 타입과 this를 직접 체크해야한다.
- 타입 관련된 테스트에서 any는 주의하고 더 엄격한 테스트를 위해 dtslint 같은 도구를 사용하는 것이 좋다.

### 테스팅을 위한 할당을 사용하는 방법의 문제점

- 불필요한 변수를 만들어야한다.
- 두 타입이 동일한지 체크하는 것이 아니라 할당 가능성을 체크하고 있기 때문에 원시값 할당일 경우 잘 동작하였다가 객체의 타입 체크에서 문제를 발견하는 경우가 있다.

#### 문제 해결 방법

Parameters와 ReturnType 제너릭 타입을 이용해 함수의 매개변수 타입과 반환 타입만 분리하여 테스트 할 수 있다.
