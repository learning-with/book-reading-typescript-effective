# 3장 타입 추론
## 아이템19. 추론 가능한 타입을 사용해 장황한 코드 방지하기
타입 추론이 된다면 명시적 타입 구문은 필요하지 않음
객체 리터럴을 정의할 때 타입을 명시하면 잉여 속성 체크가 동작 => 할당하는 시점에서 오류 표시
반환값 또한 명시하여, 호출한 코드에서가 아닌 반환시점에서 오류 표시 
- 반환 타입을 명시하면 함수에 대해 더욱 명확하게 알 수 있으며 전체 타입 시그니처를 먼저 작성해도 함수의 시그니처는 쉽게 바뀌지 않음
- 명명된 타입을 명시하여 더욱 직관적인 표현 가능

## 아이템20. 다른 타입에는 다른 변수 사용하기
변수의 값은 바뀔 수 있지만 그 타입은 보통 바뀌지 않음 or 좁히기만 가능 => 초기화시점에서 유니온 타입으로 타입을 확장
유니온 타입의 경우 타입을 확인해야 하기 때문에 별도의 변수 도입 권장
#### 다른 타입에는 별도의 변수를 사용하는 이유
- 서로 관련이 없는 두 개의 값을 분리
- 변수명을 더 구체적으로 작명 가능
- 타입 추론을 향상시키며, 타입 구문이 불필요해짐
- 타입이 더 간결해짐(유니온 X)
- let 대신 const로 변수를 선언하면 코드가 간결해지고 타입 체커가 타입을 추론하기 편리

## 아이템21. 타입 넓히기
런타임에 모든 변수는 유일한 값을 가지지만, 타입스크립트의 정적 분석 시점에 변수는 가능한 값들의 집합인 타입을 가짐
즉, 지정된 단일 값을 가지고 할당 가능한 값들의 집함을 유추(넓히기widening)
```
interface Vector3 { x: number, y: number: z: number; }
function getComponent(vector: Vector3, axis: 'x' | 'y' | 'z') {
  return vector[axis];
}

let x = 'x';  // 할당 시점에 넓히기가 동작해서 string으로 추론
let vec = {x: 10, y: 20, z: 20};
getComponent(vec, x);  // string은 'x' | 'y' | 'z'에 할당 불가능으로 에러

const x = 'x';  // const 키워드로 선언하면 더 좁은 타입이 되어 타입은 'x'
let vec = {x: 10, y: 20, z: 20};
getComponent(vec, x);  // string은 'x' | 'y' | 'z'에 할당 불가능으로 에러
```
## 아이템22. 타입 좁히기
## 아이템23. 한꺼번에 객체 생성하기
## 아이템24. 일관성 있는 별칭 사용하기
## 아이템25. 비동기 코드에는 콜백 대신 async 함수 사용하기
## 아이템26. 타입 추론에 문맥이 어떻게 사용되는지 이해하기
## 아이템27. 함수형 기법과 라이브러리로 타입 흐름 유지하기

# 4장. 타입 설계
## 아이템28. 유효한 상태만 표현하는 타입을 지향하기
## 아이템29. 사용할 때는 너그럽게, 생성할 때는 엄격하게
## 아이템30. 문서에 타입 정보를 쓰지 않기
## 아이템31. 타입 주변에 null 값 배치하기
## 아이템32. 유니온의 인터페이스보다는 인터페이스의 유니온을 사용하기
## 아이템33. string 타입보다 더 구체적인 타입 사용하기
## 아이템34. 부정확한 타입보다는 미완성 타입을 사용하기
## 아이템35. 데이터가 아닌, API와 명세를 보고 타입 만들기
## 아이템36. 해당 분야의 용어로 타입 이름 짓기
## 아이템37.  공식 명칭에는 상표를 붙이기
