# 3장 타입추론

타입 추론은 수동으로 명시해야 하는 타입 구문의 수를 줄여 주기 때문에, 타입 추론을 적극적으로 수행하되 중요한 부분에서는 타입을 명시하도록 하자.

- 어떻게 타입을 추론하는지, 언제 타입 선언을 작성해야하는지, 타입 추론이 가능하더라도 명시적 타입 선언을 작성하는 것이 필요한 상황이 언제인지 알아보자.

## 19 추론 가능한 타입을 사용해 장황한 코드 방지하기

타입 추론이 된다면 굳이 명시적 타입 구문은 필요하지 않다.

```typescript
let x = 12; // let x : number
```

- 값에 타입을 추가로 작성하는 것은 불필요하다.
- 때론 타입스크립트가 명시하는 것보다 정확하게 추론을 해내는 경우가 있다.
- 타입 추론이 되면 리팩터링도 용이해진다.
  > 책에서 말하는 좋은 예시

```typescript
interface Product {
  id: number;
  name: string;
  price: name;
}

function logProduct(product: Product) {
  // 비구조화 할당문은 모든 지역 변수의 타입이 추론되도록 한다.
  const { id, name, price } = product;
  console.log(id, name, price);
}
```

- 이상적인 타입스크립트 코드는 함수/메서드 시그니처에 타입 구문을 포함하지만 **함수 내에 생성된 지역 변수에는 타입 구문을 넣지않는다.**
- 타입 구문을 생략하여 코드의 가독성을 높이는 것이 좋다.
- 타입 정보가 있는 라이브러리에서 콜백 함수의 매개변수 타입은 자동으로 추론된다.
  > express HTTP 예시
  ```typescript
  app.get("/health", (req, res) => {
    // req : express.Request, res : express.Response 로 자동 추론된다.
    res.send("Ok");
  });
  ```

#### 타입이 추론 될 수 있음에도 타입 명시를 하는 경우

- 잉여속성 체크를 이용해 선택적 속성이 있는 타입의 오타 같은 오류를 잡는데 효과적이다.
- 타입구문을 제거하면 잉여 속성 체크가 동작하지 않고 객체 선언한 곳이아니라 객체가 사용되는 곳에서 타입 오류가 발생한다. (= 오류가 발생한 곳을 바로 알기 어려움) 타입 구문을 제대로 명시한다면 실제로 실수가 발생한 부분에 오류를 표시해준다.

```typescript
const furby: Product = {
  name: "Furby",
  id: 630509430963,
  // ~ 'number' 형식은 'string' 형식에 할당할 수 없습니다.
  price: 35,
};

logProduct(furby);
```

- 반환 타입을 명시하면 구현상 오류가 사용자 코드의 오류로 표시되지 않는다. (Promise 관련 특정 오류는 async 함수로 피하기)

#### 반환값에 타입을 명시해야하는 이유

- 타입을 명시하는 방법은 TDD(test driven development: 테스트 주도 개발)방식과 비슷하게 테스트를 먼저 작성하는 경우에도 유용하다.
- 반환 타입을 명시하면 더욱 직관적인 표현이된다. 추론된 반환 타입이 복잡해질 수록 타입을 명시하도록 하자.
- eslint 규칙 중 no-inferrable-types를 사용해 작성된 모든 타입 구문이 정말로 필요한지 확인 가능하다.

#### 타입 추론이 된다면 타입 구문을 작성하지 않는 것이 가독성면에서 좋지만, 테스트를 위해 반환값을 체크하거나 내부 구현시 오류의 위치가 제대로 나타나기 위해서는 타입 명시를 하는 편이 좋다.

## 20 다른 타입에는 다른 변수 사용하기

같은 변수명을 쓰지만 서로 다른 타입일 경우 유니온 타입을 사용할 수 있지만 string이나 number 같은 간단한 타입에 비해 다루기 어려움으로 별도의 변수를 도입하는 편이 좋다.

- 서로 관련 없는 두개의 값 분리하기
- 유니온 타입보다는 const 변수를 선언해 서로 관련없는 두 개의 값을 분리하자
- 타입이 바뀌는 변수는 피하도록 하자
- shadowed 변수(스코프가 다른 변수?)와 헷갈림 주의하기!

  > shdowed 변수 예시

```typescript
const id = "12-34-56";
fetchProduct(id);

{
  const id = 12345;
  fetchProductBySeriaNumber(id);
}
```

## 21 타입 넓히기

타입 넓히기(widening) : 지정된 단일 값을 가지고 할당 가능한 값들의 집합을 유추해야한다.

- 타입 넓히기를 할 때 추론된 타입이 여러개이기 때문에 과정이 상당히 모호하다.

#### 타입 넓히기를 제어하는 방법

1. const

```typescript
const x = "x"; // 타입이 x

let vec = { x: 10, y: 20, z: 30 };

getComponent(vec, x); // 정상
```

2. 타입스크립트 기본 동작을 재정의 하기
   - 명시적 타입 구문 제공, 타입 체커에 추가적인 문맥 제공, const 단언문 사용(as const)

#### 넓히기로 인해 오류가 발생한다고 생각이들면, 타입 넓히기를 제어 하자.

## 22 타입 좁히기

타입 좁히기 : 넓은 타입으로부터 좁은 타입으로 진행하는 과정(null 체크 등)

- 타입 체커는 일반적으로 조건문에서 타입 좁히기를 잘 해내지만, 타입 별칭이 존재한다면 그러지 못할 수도 있다.
- 분기문에서 예외를 던지거나 함수를 반환하여 블록의 나머지 부분에서 변수의 타입을 좁히기
- instanceof를 사용해 속성 체크로 타입 좁히기
- Array.isArray 같은 일부 내장 함수로 타입 좁히기

  > 단, 타입을 섣불리 판단하는 실수를 저지르기 쉬우므로 다시 꼼꼼하게 따져 볼 것!

- 태그된/ 구별된 유니온과 사용자 정의 타입 가드를 사용하여 타입 좁히기 과정을 원할하게 만들 수 있다.

#### 타입스크립트가 타입을 식별하지 못한다면 커스텀 함수를 도입하는 것처럼 타입 좁히기를 통해 타입 추론을 할 수 있게 한다. 타입 체커를 효율적으로 이용하려면 편집기에서 타입을 조사하는 습관을 가지자

## 23 한꺼번에 객체 생성하기

속성을 제각각 추가하지 말고 인터페이스 생성과 같이 한꺼번에 객체로 생성할 수 있다.

- 객체에 조건부로 속성을 추가하는 방법을 익히도록 하자( 헬퍼 함수 등)
- 안전한 타입으로 속성을 추가하려면 스프레드 연산자(객체 전개 : {...a, ...b})를 사용하자

## 24 일관성 있는 별칭 사용하기

객체 내의 프로퍼티에 별칭을 줄 경우, 별칭의 값을 변경하면 원래 속성값도 변경된다.

- 별칭을 남발해서 사용하면 제어 흐름 분석이 어렵고, 코드 가독성이 떨어짐으로 별칭을 신중하게 사용하자. 별칭을 일관성 있게 사용한다는 기본 원칙(golden rule)을 지키면 제어 흐름 분석이 방해되어 발생하는 오류를 방지할 수 있다.
- 객체 비구조화를 이용하면 보다 간결한 문법으로 일관된 이름을 사용할 수 있다.(일관된 이름을 사용하자)

> 객체 비구조화 시 주의할 점
>
> - 전체 속성이 아니라 x와 y가 선택적 속성일 경우 속성 체크가 더 필요하므로 타입의 경계에 null값을 추가하는 것이 좋다.
> - ??

- 별칭은 타입 체커 뿐만 아니라 런타임에도 혼동을 야기할 수 있다. 타입스크립트의 제어 흐름 분석은 지역 변수에는 잘 작동하지만 객체 속성에서는 주의해야한다.
- 함수 호출이 객체 속성의 타입 정제를 무효화 할 수 있다는 점을 주의해야 한다. 속성보다 지역 변수를 사용하면 타입 정제를 믿을 수 있다.

## 25 비동기 코드에는 콜백 대신 async 함수 사용하기

- 콜백보다는 프로미스가 코드를 작성하기 쉽고 타입을 추론하기 쉽다. (프로미스보다는 async/await 권장)
- 더 간결하고 직관적인 코드가 된다.
- async 함수는 항상 프로미스를 반환하도록 한다. ( API를 래핑할 때는 async/await을 사용하자)
- async 함수에서 프로미스를 반환하면 또 다른 프로미스로 래핑되지 않는다.

## 26 타입 추론에 문맥이 어떻게 사용되는지 이해하기

> 문자열 타입을 더 특정하여 문자열 리터럴 타입의 유니온으로 바꾼다고 가정할 때

```typescript
type Language = "JavaScript" | "TypeScript" | "Python";

function setLanguage(language: Laguage) {
  /* ... */
}

setLanguage("Javascript"); // 정상

let language = "JavaScript";
setLanguage(language);
// ~~~ string 형식의 인수는 language 형식의 매개변수에 할당될 수 없습니다.
```

위 예제 해결 방법

1. 직접 타입 할당하기
2. const 사용하기

```typescript
let language: Language = "JavaScript"; // 1
setLanguage(language);

const language = "JavaScript"; // 2
setLanguage(language);
```

- 변수가 상수라면 상수 단언을 사용해야한다. 상수단언을 사용하면 선언한 곳이 아니라 호출한 곳에서 오류가 발생하므로 주의하자.

## 27 함수형 기법과 라이브러리로 타입 흐름 유지하기

타입 흐름을 개선하고, 가독성을 높이고, 명시적인 타입 구문의 필요성을 줄이기 위해 직접 구현하기보다는 내장된 함수형 기법과 로대시 같은 유틸리티 라이브러리를 사용하는 것이 좋다.

# 4장 타입 설계

타입 시스템의 큰 장점 중 하나는 데이터 타입을 명확히 알 수 있어 코드를 이해하기 쉽다는 것

## 28 유효한 상태만 표현하는 타입을 지향하기

- 효과적으로 타입을 설계하려면, 유효한 상태만 표현할 수 있는 타입을 만들어 내는 것이 가장 중요
- 상태 객체의 필드를 전부 고려해서 상태 표시를 분기해야 한다.
- 타입을 설계할 때는 어떤 값들을 포함하고 어떤 값들을 제외할지 신중하게 생각해야 한다.
- 유효한 상태와 무료한 상태를 둘 다 표현하는 타입은 혼란을 초래하기 쉽고 오류를 유발하게 되므로 유효한 상태만 표현하는 타입을 지향하도록 하자.
- 유효한 상태를 표현하는 값만 허용한다면 코드 작성이 쉬워지고 타입 체크가 용이해지지만 특정한 상황에 지켜야할 원칙들도 있다.

## 29 사용할 때는 너그럽게, 생성할 때는 엄격하게

- 보통 매개변수 타입은 반환 타입에 비해 범위가 넓은 경향이 있다.
- 선택적 속성과 유니온 타입은 반환 타입보다 매개변수 타입에 더 일반적이다.
- 매개변수와 반환 타입의 재사용을 위해서 기본 형태와 느슨한 형태를 도입하는 것이 좋다.

## 30 문서에 타입 정보를 쓰지 않기

= 주석이나 변수명에 타입 정보 쓰지 않기

- 함수 입출력의 타입을 코드로 표현하는 것이 주석보다 더 나은 방법이다.
- 만약 특정 매개변수를 설정하고 싶다면 JSDoc의 @param 구문을 사용하면 된다.
- 읽기 전용이라는 것을 주석으로 표시하는 것보다는 readonly를 사용하자.
- 단위가 있는 숫자들을 제외하고는 타입정보는 변수명에 넣지말자.
  - `ageNum` X, `age : number`
  - `timeMs`, `temperatureC`

## 31 타입 주변에 null값 배치하기

- 한 값의 null 여부가 다른 값의 null 여부에 암시적으로 관련되도록 설계하면 안된디.
- API 작성 시에는 반환 타입을 큰 객체로 만들고 반환 타입 전체가 null 이거나 null이 아니게 만들어야 한다. 사람과 타입 체커 모두에게 명료한 코드가 될 것이다.
- 클래스를 만들 때는 필요한 모든 값이 준비되었을 때 생성하여 null이 존재하지 않도록 하는 것이 좋다.
- strictNullChecks를 설정하면 코드의 많은 오류가 표시되겠지만, null값과 관련된 문제점을 찾아낼 수 있기 때문에 반드시 필요하다.

## 32 유니온의 인터페이스보다 인터페이스의 유니온 사용하기

- 유니온 타입의 속성을 여러개 가지는 인터페이스에서는 속성 간의 관계가 분명하지 않기 때문에 실수가 자주 발생하므로 주의하여야한다.

  유니온의 인터페이스 예시

```typescript
interface Layer {
  layout: FillLayout | LineLayout | PointLayout;
  paint: FillPaint | LinePaint | PointPaint;
}
```

인터페이스의 유니온 예시

```typescript
interface FillLayout {
  layout: FillLayout;
  paint: FillPaint;
}
interface LineLayer {
  layout: LineLayout;
  paint: LinePaint;
}
interface PointLayer {
  layout: PointLayout;
  paint: PointPaint;
}

type Layer = FillLayer | LineLayer | PointLayer;
```

- 인터페이스의 유니온 방식으로 정의하면 layout과 paint 속성이 잘못된 조합으로 섞이는 경우를 방지할 수 있다.
- 위 코드에서는 유효한 상태의 값만 정의하였지만 각 인터페이스에 type 속성을 추가하여 태그된 유니온 형태로 작성하면 타입스크립트가 태그를 참조하여 layer의 타입 범위를 좁힐 수 있다.
- 타입스크립트가 제어 흐름을 분석할 수 있도록 타입에 태그를 넣는 것을 고려해야 한다. 태크된 유니온은 타입스크립트와 매우 잘 맞기 때문에 자주 볼 수 있는 패턴이다.
- 각 타입의 속성들 간의 관계를 제대로 모델링하면, 타입스크립트가 코드의 정확성을 체크하는데 도움이 된다.

#### 타입 구조를 손댈 수 없는 상황일 경우(API의 결과)

인터페이스의 유니온을 사용해서 속성 사이의 관계를 모델링할 수 있다.

```typescript
interface Person {
  name: string;
  birth?: {
    place: string;
    date: Date;
  };
}

interface Name {
  name: string;
}

interface PersonWithBirth extends Name {
  placeOfBirth: string;
  dateOfBirth: Date;
}

type Person = Name | PersonWithBirth;

// 중첩된 객체에서도 동일한 효과를 볼 수 있다. ????
function eulogize(p: Person) {
  if ("placeOfBirth" in p) {
    p; // 타입이 PersonWithBirth
    const { dateOfBirth } = p; // 정상, 타입이 Date
  }
}
```

## 33 string 타입보다 더 구체적인 타입 사용하기

- 타입을 명시적으로 정의함으로써 다른 곳으로 값이 전달되어도 타입 정보가 유지된다.
- 타입을 명시적으로 정의하고 해당 타입의 의미를 설명하는 주석을 붙여 넣을 수 있다.

```typescript
/** 녹음이 어떤 환경에서 이루어졌는지? */
type RecordingType = "live" | "studio";
```

- 객체의 속성 이름을 함수 매개변수로 받을 때는 string보다 keyof T를 사용하는 것이 좋다.
- keyof 연산자로 더욱 세밀하게 객체의 속성 체크가 가능해진다.

```typescript
type K = keyof Album;
// 타입이 "artist" | "title" | "releaseDate" | "recordingType"

function pluck<T, K extends keyof T>(records: T[], key: keyof T): T[keyof T][] {
  return records.map(r => r[key]);
}
```

- 매개변수 타입이 정밀해지면 타입 서비스에서 Album의 키에 자동 완성 기능을 제공할 수 있다.

## 34 부정확한 타입보다는 미완성 타입을 사용하기

타입이 구체적일수록 버그를 더 많이 잡고 타입스크립트가 제공하는 도구를 활용할 수 있지만 타입 선언의 정밀도를 높이는 일에는 주의를 기울여야한다.

- 오히려 과한 타입 선언으로 인해 이전 버전보다 에러 메시지가 부정확해질 수도 있다.
- 타입 선언으로 인한 오류 메시지를 살펴보고 타입 선언이 동작해야 하는 곳에는 자동 완성을 적용하는 것이 좋다.
- 복잡한 코드가 더 많은 테스트가 필요한 만큼 타입도 마찬가지로 테스트를 추가해 놓친 부분이 없는지 확인해도 된다.
- 타입이 구체적으로 정제된다고 해서 정확도가 무조건 올라가지는 않는다. 타입에 의존하기 시작하면 부정확함으로 인해 발생하는 문제는 더 커질 것이다.

#### 어설프게 완벽을 추구하지 말자

## 35 데이터가 아닌, API 명세를 보고 타입 만들기

- 코드의 구석구석까지 타입 안정성을 얻기 위해 API 또는 데이터 형식에 대한 타입 생성을 고려해야한다.
- 명세 정보나 공식 스키마가 없다면 데이터로부터 타입을 생성해야 한다. (예시 quicktype 도구) 생성된 타입이 실제 데이터와 일치하지 않을 수 있으니 주의하자.
- 데이터에 드러나지 않는 예외적인 경우들이 문제가 될 수 있기 때문에 데이터보다는 명세로부터 코드를 생성하는 것이 좋다.

## 36 해당 분야의 용어로 타입 이름 짓기

변수나 속성명을 잘 못지으면 정보가 모호해지기 때문에 작성한 사람을 찾아서 의도를 물어봐야하는 경우가 생김으로 용어는 구체적인 용어를 사용하도록 하자.

#### 타입, 속성, 변수에 이름을 붙일 때 명심해야 할 세 가지 규칙

- 의미적으로 구분이 되어야 하는 경우에만 다른 용어를 사용하고 동일한 의미를 나타낼 때는 같은 용어를 사용하자.
- 무심코 data, info 같은 의미없는 이름을 붙이지 않도록 하자. 가독성을 높이고, 추상화 수준을 올리기 위해서 해당 분야의 용어를 사용해야 한다.
- 이름을 지을 때는 포함된 내용이나 계산 방식이 아니라 데이터 자체가 무엇인지 고려해야한다.

## 37 공식 명칭에는 상표를 붙이기

#### 스타벅스가 아니라 커피

타입스크립트는 구조적 타이핑(덕 타이핑)을 사용하기 때문에, 값을 세밀하게 구분하지 못하는 경우가 있다. 값을 구분하기 위해 공식 명칭이 필요하다면 상표를 붙이는 것을 고려해야한다.( number에도 상표를 붙일 수 있다. )

- 상표 기법은 타입 시스템에서 동작하지만 런타임에 상표를 검사하는 것과 동일한 효과를 얻을 수 있다.
- 코드에 여러 단위가 혼합된 수의 숫자가 많이 들어 있는 경우, 숫자의 단위를 문서화하는 것도 좋다.
- 상표 기법은 타입 시스템에서 동작하지만 런타임에 상표를 검사하는 것과 동일한 효과를 얻을 수 있다. 런타임 오버헤드를 없앤다거나 추가 속성을 붙일 수 없는 내장 타입(number, string)도 상표화할 수 있다.
